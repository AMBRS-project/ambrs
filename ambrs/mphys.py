"""ambrs.mphys -- data types and functions related to Jeff Pierce's aerosol
microphysics model(s). So far, we support his 1-moment sectional model
(https://github.com/AMBRS-project/mphys-1-moment-sectional)
"""

from .aerosol import AerosolProcesses, AerosolModalSizePopulation, \
                     AerosolModalSizeState
from .aerosol_model import BaseAerosolModel
from .analysis import Output
from .gas import GasSpecies
from .scenario import Scenario
from .ppe import Ensemble

from dataclasses import dataclass
import numpy as np
import os.path
import scipy.stats

@dataclass
class Input:
    """ambrs.mphys.Input -- an input dataclass for Jeff Pierce's 1-moment
sectional box model"""

    # particle size distribution info
    nbins: int # number of particle size bins (uniform spacing)
    lower_limit: float # lower bound of smallest particle size bin [m]
    upper_limit: float # upper bound of largest particle size bin [m]

    # atmospheric state
    temp: float # temperature [K]
    pres: float # pressure [Pa]

    # timestepping information
    num_steps: int # number of time steps
    tfinal: float # final time [s]

    density: float # [kg/m^3]
    coag_eff: float # scale factor for coagulation
    H2SO4: float # sulfuric acid number concentration [cm^-3]
    NucScale: float # scale factor for activation nucleation [s^-1]
    mfp: float # mean free path of air [m]
    h2so4diff: float # diffusivity of h2so4 [m^2 s^-1]

    No: tuple[float, ...] # initial number in log modes [cm-3]
    Dpm: tuple[float, ...] # initial median diameter in log modes [m]
    sigma: tuple[float, ...] # initial sigma in log modes

    doNucCondCoag: tuple[bool, ...]

class AerosolModel(BaseAerosolModel):
    def __init__(self,
                 processes: AerosolProcesses):
        BaseAerosolModel.__init__(self, 'mphys-1-moment-sectional', processes)

    def create_input(self,
                     scenario: Scenario,
                     dt: float,
                     nstep: int) -> Input:
        if dt <= 0.0:
            raise ValueError("dt must be positive")
        if nstep <= 0:
            raise ValueError("nstep must be positive")
        if not isinstance(scenario.size, AerosolModalSizeState):
            raise TypeError('Non-modal aerosol particle size state cannot be used to create mphys input!')
        if len(scenario.size.modes) != 4:
            raise TypeError(f'{len(scenario.size.mode)}-mode aerosol particle size state cannot be used to create MAM4 input!')

        return Input(
            # FIXME: magic happens here! We need to figure out how to map
            # FIXME: modes to bins, etc
        )

    def invocation(self, exe: str, prefix: str) -> str:
        return f'{exe}'

    def write_input_files(self, input, dir, prefix) -> None:
        content = f"""# generated by ambrs.mphys.AerosolModel.write_input_files

nbins={input.nbins}
density={input.density}
lower_limit={input.lower_limit}
upper_limit={input.upper_limit}
coag_eff={input.coag_eff}
temp={input.temp}
pres={input.pres}
num_times={input.num_steps}
tfinal={input.tfinal}

H2SO4={input.H2SO4}
NucScale={input.NucScale}
mfp={input.mfp}
h2so4diff={input.h2so4diff}

No = list(input.No)
Dpm = list(input.Dpm)
sigma = list(input.sigma)

doNucCondCoag = list(input.doNucCondCoag)
"""
        if not os.path.exists(dir):
            raise OSError(f'Directory not found: {dir}')
        filename = os.path.join(dir, 'input.py')
        with open(filename, 'w') as f:
            f.write(content)

    def read_output_files(self,
                          input,
                          dir: str,
                          prefix: str) -> Output:
        # the driver saves dNdlnD to a text file, so we just have to read it
        return Output(
            model = self.name,
            input = input,
            bins = input.bins,
            dNdlnD = np.loadtxt('dNdlogDp.dat'),
        )
